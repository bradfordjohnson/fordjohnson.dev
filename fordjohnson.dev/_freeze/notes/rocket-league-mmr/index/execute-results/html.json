{
  "hash": "9a0fd7dbb8983e023600775ed81acc9e",
  "result": {
    "engine": "knitr",
    "markdown": "---\npagetitle: Matchmaking in Rocket League\ndescription: |\n  Uncover the data behind Rocket League's MMR and matchmaking system, explaining how player ratings are calculated and how the system pairs competitors in ranked play.\nlightbox: true\nappendix-style: plain\nhtml-math-method:\n  method: katex\nexecute: \n  freeze: auto\n---\n\n\n\n::: column-page\n# Matchmaking in Rocket League\n\n::: {.callout-note}\n## Ongoing Analysis\n\nThis note is still in progress as I gather data and insights from other Rocket League players. Feel free to check out what I’ve compiled so far!\n:::\n\n:::\n\n::::: column-screen\n:::: portfolio-banner\n::: column-page\nAs a longtime Rocket League player, I’ve always been fascinated by the ranking system behind the game. Using tools like BakkesMod and tracking websites, I’ve been able to monitor my MMR in real time, sparking my interest in how the system works. Rocket League, like many games, uses skill-based matchmaking to create balanced matches, driven by calculations that determine player ratings and matchups. My goal is to explore the data behind this system and understand how it shapes the competitive experience.\n:::\n::::\n:::::\n\n::: {.column-page .binom}\n\n## Matchmaking Rating (MMR) and Skill Rating\n\nMost Rocket League players interested in their [competitive ranking](https://www.epicgames.com/help/en-US/c-Category_RocketLeague/c-RocketLeague_Gameplay/what-are-rocket-league-competitive-ranks-a000084481) are familiar with the skill rating displayed on third-party websites or in BakkesMod. This **skill rating** is derived from the matchmaking rank (MMR), which remains hidden and is not easily visible to players.\n\n\n$$\n\\text{mmr} \\approx \\frac{\\left(\\text{skill rating} - 100\\right)}{20}\n$$\n\n$$\n\\text{skill rating} \\approx \\left(20\\text{mmr}\\right) - 100\n$$\n\nThe MMR is the underlying numerical value that determines a player's true skill level, influencing matchmaking and overall competitive performance in Rocket League. Both casual and competitive matchmaking in Rocket League utilize skill-based matchmaking, meaning that wins and losses directly affect your skill value, leading to increases or decreases in your ranking. To balance the time spent finding eligible opponents within selected regions and prevent long wait times, the game expands the allowable skill range when necessary. Different playlists and gamemodes will have their own MMR value.\n\n### Determining a Player's Skill\n\nRocket League uses the `SkillMu` and `SkillSigma` to calculate a player's MMR. This is similar to other Bayesian approaches but not the same.^[[Reddit](https://www.reddit.com/r/RocketLeague/comments/3uv3xu/how_the_ranking_system_and_matchmaking_works_the/) - *How the Ranking System and Matchmaking works...*]\n\nSkillMu (Mu)\n: The perceived skill level of a player, which increases with wins and decreases with losses. It starts at a value of 25 in unplayed playlists.\n\nSkillSigma (Sigma)\n: The \"uncertainty\" value that decreases with each match, indicating the system's confidence in a player's skill. It starts at 8.333 in unplayed playlists and decreases as matches are played to a minimum of 2.5. A lower Sigma signifies greater certainty a player is at the correct skill level.\n\nNew players start with a SkillMu = 25, skill rating = 600 and SkillSigma = 8.333.\n\n### Matchmaking and Teams\n\n\nIn competitive Rocket League, players can choose between the following gamemodes:^[*Competitive and casual matchmaking use different weighting systems; this discussion will focus on competitive modes.*] 1v1, 2v2, 3v3.\n\n  \nThe matchmaking system employs a weighted average approach, using methods like the root mean square (RMS), to assess each team's skill and ensure fair matchups against opponents.^[[Reddit](https://www.reddit.com/r/RocketLeague/comments/ljyzcy/parties_how_they_affect_matchmaking_mmr/) - *Parties: How they affect matchmaking MMR*]\n\n$$\n\\text{Team Skill}=\\sqrt[n]{\\frac{\\mathrm{\\text{mmr}}_{1}^{n}+\\mathrm{\\text{mmr}}_{2}^{n}+\\text{...}+\\mathrm{\\text{mmr}}_{x}^{n} }{x}}\n$$\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparty_matchmaking <- function(mmr_arr, n) {\n  party_mmr <- round((sum(mmr_arr^n) / length(mmr_arr))^(1/n),0)\n  return(paste0(\"Team's Skill Rating = \", party_mmr))\n}\n\nplayer_1_mmr = 600\nplayer_2_mmr = 700\nn = 15 # this is the value for competitive playlists\n\nteam_skill <- party_matchmaking(c(player_1_mmr, player_2_mmr), n)\n\nteam_skill\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Team's Skill Rating = 673\"\n```\n\n\n:::\n:::\n\n\n\nWhen a player's skill reaches a certain threshold, the matchmaking system adjusts by basing the team's skill level entirely on the high skilled player, even if they are partied with lower-skilled teammates. This ensures that the match remains competitive despite skill imbalances within the team.\n\n## Simulating Matches\n\n\n\n::: {.cell}\n\n```{.r .cell-code .code-overflow-wrap  code-fold=\"true\"}\nlibrary(R6)\n\nRating <- R6Class(\"Rating\",\n  public = list(\n    skill_mu = 25.0,\n    skill_sigma = 25.0 / 3.0,\n    sigma_sq = NULL,\n    \n    initialize = function(skill_mu = 25.0, skill_sigma = 25.0 / 3.0) {\n      self$skill_mu <- skill_mu\n      self$skill_sigma <- skill_sigma\n      self$sigma_sq <- skill_sigma^2\n    },\n    \n    print = function() {\n      cat(sprintf(\"Rating(skill_mu=%.2f, skill_sigma=%.2f)\\n\", self$skill_mu, self$skill_sigma))\n    }\n  )\n)\n\nOutcome <- list(\n  WIN = \"Win\",\n  LOSS = \"Loss\",\n  DRAW = \"Draw\"\n)\n\nRater <- R6Class(\"Rater\",\n  public = list(\n    beta_sq = NULL,\n    \n    initialize = function(beta) {\n      self$beta_sq <- beta^2\n    },\n    \n    update_ratings = function(teams, ranks) {\n      if (length(teams) != length(ranks)) {\n        stop(\"`teams` and `ranks` vectors must be of the same length\")\n      }\n      \n      team_mu <- numeric(length(teams))\n      team_sigma_sq <- numeric(length(teams))\n      team_omega <- numeric(length(teams))\n      team_delta <- numeric(length(teams))\n      \n      for (team_idx in seq_along(teams)) {\n        team <- teams[[team_idx]]\n        if (length(team) == 0) {\n          stop(\"At least one of the teams contains no players\")\n        }\n        \n        for (player in team) {\n          team_mu[team_idx] <- team_mu[team_idx] + player$skill_mu\n          team_sigma_sq[team_idx] <- team_sigma_sq[team_idx] + player$sigma_sq\n        }\n      }\n      \n      for (team_idx in seq_along(teams)) {\n        for (team2_idx in seq_along(teams)) {\n          if (team_idx == team2_idx) next\n          \n          c <- sqrt(team_sigma_sq[team_idx] + team_sigma_sq[team2_idx] + 2.0 * self$beta_sq)\n          e1 <- exp(team_mu[team_idx] / c)\n          e2 <- exp(team_mu[team2_idx] / c)\n          piq <- e1 / (e1 + e2)\n          pqi <- e2 / (e1 + e2)\n          ri <- ranks[team_idx]\n          rq <- ranks[team2_idx]\n          \n          s <- if (rq > ri) 1.0 else if (rq == ri) 0.5 else 0.0\n          \n          delta <- (team_sigma_sq[team_idx] / c) * (s - piq)\n          gamma <- sqrt(team_sigma_sq[team_idx]) / c\n          eta <- gamma * (team_sigma_sq[team_idx] / (c^2)) * piq * pqi\n          \n          team_omega[team_idx] <- team_omega[team_idx] + delta\n          team_delta[team_idx] <- team_delta[team_idx] + eta\n        }\n      }\n      \n      result <- list()\n      \n      for (team_idx in seq_along(teams)) {\n        team_result <- list()\n        \n        for (player in teams[[team_idx]]) {\n          new_mu <- player$skill_mu + (player$sigma_sq / team_sigma_sq[team_idx]) * team_omega[team_idx]\n          sigma_adj <- 1.0 - (player$sigma_sq / team_sigma_sq[team_idx]) * team_delta[team_idx]\n          sigma_adj <- max(sigma_adj, 0.0001)\n          \n          new_sigma_sq <- player$sigma_sq * sigma_adj\n          \n          team_result[[length(team_result) + 1]] <- Rating$new(skill_mu = new_mu, skill_sigma = sqrt(new_sigma_sq))\n        }\n        \n        result[[length(result) + 1]] <- team_result\n      }\n      \n      return(result)\n    },\n    \n    duel = function(p1, p2, outcome) {\n      teams <- list(list(p1), list(p2))\n      ranks <- if (outcome == Outcome$WIN) c(1, 2) else if (outcome == Outcome$LOSS) c(2, 1) else c(1, 1)\n      \n      result <- self$update_ratings(teams, ranks)\n      \n      return(list(result[[1]][[1]], result[[2]][[1]]))\n    }\n  )\n)\n\nPlayer <- R6Class(\"Player\",\n  public = list(\n    name = NULL,\n    rating = NULL,\n    \n    initialize = function(name) {\n      self$name <- name\n      self$rating <- Rating$new()\n    },\n    \n    print = function() {\n      cat(sprintf(\"%s: \", self$name))\n      self$rating$print()\n    }\n  )\n)\n\nsimulate_duels <- function(rater, players, num_duels) {\n  for (i in seq_len(num_duels)) {\n    selected_players <- sample(players, 2)\n    p1 <- selected_players[[1]]\n    p2 <- selected_players[[2]]\n    \n    outcome <- sample(c(Outcome$WIN, Outcome$LOSS), 1)\n    \n    cat(sprintf(\"\\n1v1 game %d: %s vs %s -> %s\\n\", i, p1$name, p2$name, outcome))\n    \n    result <- rater$duel(p1$rating, p2$rating, outcome)\n    \n    new_p1 <- result[[1]]\n    new_p2 <- result[[2]]\n    \n    delta_p1_mu <- new_p1$skill_mu - p1$rating$skill_mu\n    delta_p1_sigma <- new_p1$skill_sigma - p1$rating$skill_sigma\n    delta_p2_mu <- new_p2$skill_mu - p2$rating$skill_mu\n    delta_p2_sigma <- new_p2$skill_sigma - p2$rating$skill_sigma\n    \n    cat(sprintf(\"Results:\\n%s: skill_mu = %.2f (Δ=%.2f), skill_sigma = %.2f (Δ=%.2f)\\n\", \n                p1$name, new_p1$skill_mu, delta_p1_mu, new_p1$skill_sigma, delta_p1_sigma))\n    cat(sprintf(\"%s: skill_mu = %.2f (Δ=%.2f), skill_sigma = %.2f (Δ=%.2f)\\n\", \n                p2$name, new_p2$skill_mu, delta_p2_mu, new_p2$skill_sigma, delta_p2_sigma))\n  }\n}\n\nrater <- Rater$new(beta = 25.0 / 3.0)\n\nplayers <- lapply(1:2, function(i) Player$new(name = paste(\"Player\", i)))\n\nsimulate_duels(rater, players, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n1v1 game 1: Player 1 vs Player 2 -> Loss\nResults:\nPlayer 1: skill_mu = 22.92 (Δ=-2.08), skill_sigma = 8.20 (Δ=-0.13)\nPlayer 2: skill_mu = 27.08 (Δ=2.08), skill_sigma = 8.20 (Δ=-0.13)\n\n1v1 game 2: Player 1 vs Player 2 -> Win\nResults:\nPlayer 1: skill_mu = 27.08 (Δ=2.08), skill_sigma = 8.20 (Δ=-0.13)\nPlayer 2: skill_mu = 22.92 (Δ=-2.08), skill_sigma = 8.20 (Δ=-0.13)\n\n1v1 game 3: Player 1 vs Player 2 -> Loss\nResults:\nPlayer 1: skill_mu = 22.92 (Δ=-2.08), skill_sigma = 8.20 (Δ=-0.13)\nPlayer 2: skill_mu = 27.08 (Δ=2.08), skill_sigma = 8.20 (Δ=-0.13)\n```\n\n\n:::\n:::\n\n\n\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}